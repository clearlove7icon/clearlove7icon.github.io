<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/23/关于本地存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/23/关于本地存储/" itemprop="url">关于本地存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T17:13:34+08:00">
                2017-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="H5本地存储"><a href="#H5本地存储" class="headerlink" title="H5本地存储"></a>H5本地存储</h3><p>在以前，我们想要存储一些数据，并且只是在前端使用，服务端并不会使用，我们只能存在cookie里，但是cookie会跟随请求头在客户端和服务端之间来回传递，而且cookie还有一些缺点，H5提供了webStorage的API用来做客户端的数据存储</p>
<h5 id="cookie与webStorage的区别"><a href="#cookie与webStorage的区别" class="headerlink" title="cookie与webStorage的区别"></a>cookie与webStorage的区别</h5><ol>
<li>cookie有大小的限制，只能存储4kb，webStorage可以存储5Mb，cookie还有条数的限制</li>
<li>cookie会跟随请求头在客户端和服务端之间传递，会影响带宽。</li>
<li>cookie需要设置有效期，localStorage是永久保存，sessionStorage是会话保存，</li>
<li>cookie可以设置作用path</li>
<li>cookie的操作较为困难，webStorage的API较为容易</li>
<li>cookie的兼容性比webStorage兼容性好</li>
</ol>
<h5 id="webStorage包含的存储方式"><a href="#webStorage包含的存储方式" class="headerlink" title="webStorage包含的存储方式"></a>webStorage包含的存储方式</h5><ol>
<li>localStorage ：有效期是永远，永久保存；除非手动删除</li>
<li>sessionStorage： 有效期是一次会话时间</li>
<li>globalStorage、indexedDB、webSQL因为兼容性、实用性较差，所以，不使用</li>
</ol>
<h5 id="localStorage和sessionStorage-的使用方法（API）"><a href="#localStorage和sessionStorage-的使用方法（API）" class="headerlink" title="localStorage和sessionStorage 的使用方法（API）"></a>localStorage和sessionStorage 的使用方法（API）</h5><ol>
<li><p>localStorage和sessionStorage的使用方法一样</p>
</li>
<li><p>增删改查</p>
</li>
</ol>
<p>增/改： localStorage.setItem(key,value)/ localStorage.a = 1</p>
<p>查： length；key方法（index）得到对应的key getItem(key)/localStorage.a</p>
<p>删： removeItem（key）</p>
<p>清空: clear()</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/23/关于Ajax缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/23/关于Ajax缓存/" itemprop="url">关于Ajax缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T17:09:58+08:00">
                2017-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ajax页面缓存是ajax处理数据时对一些重复相同数据进行一个缓存操作，这样从另一个层面对于我们来讲是非常的不错了，但有时我们并不希望它缓存要如何处理呢？下面我们一起来看看关于页面缓存问题分析与解决，希望例子对各位会带来帮助。</p>
<p>一、什么是Ajax缓存原理？<br>Ajax在发送的数据成功后，会把请求的URL和返回的响应结果保存在缓存内，当下一次调用Ajax发送相同的请求时，它会直接从缓存中把数据取出来，这是为了提高页面的响应速度和用户体验。当前这要求两次请求URL完全相同，包括参数。这个时候，浏览器就不会与服务器交互。<br>二、Ajax缓存的好处<br>这种设计使客户端对一些静态页面内容的请求，比如图片，css文件，js脚本等，变得更加快捷，提高了页面的响应速度，也节省了网络通信资源。</p>
<p>三、Ajax缓存的不足<br>Ajax缓存虽然有上述的好处，但是如果通过Ajax对一些后台数据进行更改的时候，虽然数据在后台已经发生改变，但是页面缓存中并没有改变，对于相同的URL，Ajax提交过去以后，浏览器还只是简单的从缓存中拿数据，这种情况当然就不行了。</p>
<p>四、解决Ajax缓存问题的方法<br>解决这个问题最有效的办法是禁止页面缓存，有以下几种处理方法：<br>1、在ajax发送请求前加上 xmlHttpRequest.setRequestHeader(“Cache-Control”,”no-cache”);<br>2、在服务端加 header(“Cache-Control: no-cache, must-revalidate”);<br>3、在ajax发送请求前加上 xmlHttpRequest.setRequestHeader(“If-Modified-Since”,”0″);<br>4、在 Ajax 的 URL 参数后加上 “?fresh=” + Math.random(); //当然这里参数 fresh 可以任意取了<br>5、第五种方法和第四种类似，在 URL 参数后加上 “?timestamp=” + new Date().getTime();<br>6、用POST替代GET：不推荐<br>7、jQuery提供一个防止ajax使用缓存的方法：</p>
<p><script type="text/javascript" language="javascript"><br>     $.ajaxSetup ({<br>           cache: false //close AJAX cache<br>      });<br></script><br>8、修改load 加载的url地址，如在url 多加个时间参数就可以：<br>function loadEventInfoPage(eventId){<br>    $.ajaxSetup ({<br>       cache: true // AJAX cache  下面加上时间后load的页面中的js、css图片等都会重新加载，<br>         //加上这句action会重新加载，但是js、css、图片等会走缓存<br>    });<br>    $(“#showEventInfo”).load(ctx + “/custEvents/viewEvent.action”,  {“complaint.Id”:eventId, “tt”:(new Date()).getTime()},function(){})<br>}</p>
<p>9、设置html的缓存</p>
<p><meta http-equiv="Pragma" content="no-cache">   </p>
<p><meta http-equiv="Cache-Control" content="no-cache">   </p>
<meta http-equiv="Expires" content="0">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/node4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/node4/" itemprop="url">node4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T12:14:27+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="node第五课"><a href="#node第五课" class="headerlink" title="node第五课"></a>node第五课</h2><p>使用EXPRESS+MONGODB+EJS+BOOTSTRAP实现一个小型电商网站</p>
<h5 id="功能实现（主要技术点）"><a href="#功能实现（主要技术点）" class="headerlink" title="功能实现（主要技术点）"></a>功能实现（主要技术点）</h5><ol>
<li><p>登陆注册、登陆信息判断</p>
</li>
<li><p>轮播图</p>
<p> 使用服务端渲染的方式，因为轮播部分在用户使用过程中不会出现再次操作数据的情况，初始化的时候显示就可以。</p>
<p> 后端接收到请求首页后，获取轮播图数据，然后在渲染ejs，模板的时候将数据载入</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// node router...</span><br><span class="line">connect_mongo((db)=&gt;&#123;//连接数据库</span><br><span class="line">    db.collection(&apos;banner&apos;).find(&#123;&#125;).toArray((err,results)=&gt;&#123;//查找数据</span><br><span class="line">    if(err) throw err;</span><br><span class="line">    res.render(&apos;index&apos;, &#123;banners:results&#125;);//渲染模板</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">// ejs...</span><br><span class="line">&lt;% banners.forEach((item,i)=&gt;&#123; %&gt;</span><br><span class="line">    &lt;li data-target=&quot;#carousel-example-generic&quot; class=&quot;&lt;%= i==0?&apos;active&apos;:&apos;&apos; %&gt;&quot; data-slide-to=&quot;&lt;%= i %&gt;&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="ejs模板语法："><a href="#ejs模板语法：" class="headerlink" title="ejs模板语法："></a>ejs模板语法：</h5><ol>
<li>所有ejs语句都要用 &lt;% %&gt;来包裹，类似于php中的 &lt;?php ?&gt;</li>
<li>输出内容用 &lt;%= value %&gt;</li>
<li>输出内容需要解析成html，使用 &lt;%- %&gt;,在很多时候，数据库里存储的数据很可能是一个标签格式的字符串，需要使用这种方式来渲染</li>
<li>在一个ejs模板里可以引入另一个ejs模板  &lt;%= include(url) %&gt;</li>
</ol>
<h5 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h5><p>回流和重绘是在前端开发中浏览器经常出现的一种情况</p>
<p>回流：当我们使用js等方法来动态改变页面中某一个元素的宽高、大小、浮动等等操作的时候（更改了文档流结构的时候）<br>重绘：当我们使用js等方法来动态改变页面中某一个元素的背景颜色、color等等操作的时候(没有更改大的dom文档结构),</p>
<p>避免回流</p>
<p>能visibility：none就不要dispaly：none</p>
<h5 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h5><p>当用户来回的在多个页内标签页间切换的时候，会持续的产生数据请求，而请求的数据很可能是和之前请求到的是一样的，所以我们可以做一个缓存机制，当一次获取数据后将获取到的数据存在一个变量、cookie中，每次产生用户操作后都去判断缓存是否存在，如果存在的话就直接使用，否则重新获取并存人缓存，需要注意的是，为缓存做一个生命周期，定期销毁，保证当有新数据的时候也可以请求到。</p>
<h5 id="JS中正则加变量："><a href="#JS中正则加变量：" class="headerlink" title="JS中正则加变量："></a>JS中正则加变量：</h5><p>正则字面量(/ /)加变量不像字符串拼接变量那么简单，因为无论你怎么写，都会被当作正则的一部分来处理。</p>
<p>可以用构造函数来生成正则表达式：</p>
<p>ew RegExp(“^\d+” + v + “$”,”gim”);</p>
<h5 id="在mongodb中根据-id主键来查找数据"><a href="#在mongodb中根据-id主键来查找数据" class="headerlink" title="在mongodb中根据_id主键来查找数据"></a>在mongodb中根据_id主键来查找数据</h5><p>mongodb在存储数据的时候会自动的为每一个document生成一个_id主键，我们在nodeJS中根据_id查找的时候要注意一点，不能直接：</p>
<p>let _id = ‘5a0bc041bf680d5ee434683d’<br>coll.find({_id:_id})</p>
<p>需要从mongodb模块中引入ObjectID方法，这个方法可以将上面的字符串转成mongodb数据库可以识别的_id数据类型</p>
<p>var ObjectID = require(“mongodb”).ObjectID<br>let _id = ‘5a0bc041bf680d5ee434683d’<br>coll.find({_id:ObjectID(_id)})</p>
<h5 id="CSS3动画复习"><a href="#CSS3动画复习" class="headerlink" title="CSS3动画复习"></a>CSS3动画复习</h5><ol>
<li><p>CSS3动画在移动端或者兼容要求不高的项目中应该大量使用，因为CSS3动画的性能更高，渲染更流畅，功能性更强</p>
</li>
<li><p>在使用动画前应该先利用@keyframes name定义动画,括号里可以写百分百或者from to,可以将整个动画运行的时间看成时间轴，在对应的时间节点变化成不同的css属性</p>
</li>
<li><p>在css中利用animation属性来使用已经定义好的动画，最少需要加上动画名字和持续时间的属性</p>
</li>
</ol>
<p>在这里使用animate.css动画库</p>
<p>需要添加animated类型，这样元素有了动画执行时间，在加上对应的动画类名，就会拥有执行的动画名字</p>
<p>注意如果需要动画在用户操作后重新执行动画，需要将类名去掉再加上，这个时候浏览器可能反应不过来，加一个setTimeout,0;</p>
<p>还可以使用animationEnd的事件，在动画执行完成后触发</p>
<h5 id="利用cookie来进行前后端数据交互"><a href="#利用cookie来进行前后端数据交互" class="headerlink" title="利用cookie来进行前后端数据交互"></a>利用cookie来进行前后端数据交互</h5><p>有的时候，前端在请求数据之前会将相关参数存在cookie里，然后后端根据请求头中携带的cookie信息来判断做出不同的响应</p>
<hr>
<p>分类： 手机 1  衣服 2   书 3</p>
<p>goods</p>
<p>db.goods.insertMany([{keyword:”华为 7X 7x huawei 华为7X”,name:”华为7X”,”price”:1820,imgurl:”/images/goods/phone/hw-7x-1820.jpg”,classid:1,hot:1658},{keyword:”华为 V8 v8 huawei 华为V8”,name:”华为V8”,”price”:1699,imgurl:”/images/goods/phone/hw-v8-1699.jpg”,classid:1,hot:9864},<br>{keyword:”苹果 apple iphone i8 iphone 8Plus”,name:”iphone 8Plus”,”price”:6088,imgurl:”/images/goods/phone/ip-8p-6088.jpg”,classid:1,hot:4596},<br>{keyword:”锤子 坚果 pro 锤子坚果pro”,name:”锤子坚果pro”,”price”:1499,imgurl:”/images/goods/phone/jg-pro-1499.jpg”,classid:1,hot:9654},<br>{keyword:”oppo r11 R11 oppoR11S”,name:”oppoR11S”,”price”:2999,imgurl:”/images/goods/phone/op-r11-2999.jpg”,classid:1,hot:865},<br>{keyword:”mi MI 小米 note note3 小米note3”,name:”小米note3”,”price”:2099,imgurl:”/images/goods/phone/xm-n3-2099.jpg”,classid:1,hot:4986},<br>{keyword:”棉袄 白 白棉袄”,name:”白棉袄”,”price”:249,imgurl:”/images/goods/clothes/1.jpg”,classid:2,hot:896},<br>{keyword:”棉袄 黑 黑棉袄”,name:”黑棉袄”,”price”:299,imgurl:”/images/goods/clothes/2.jpg”,classid:2,hot:1468},<br>{keyword:”棉袄 蓝 蓝棉袄”,name:”蓝棉袄”,”price”:589,imgurl:”/images/goods/clothes/3.jpg”,classid:2,hot:542},<br>{keyword:”夹克 黑 黑夹克”,name:”黑夹克”,”price”:199,imgurl:”/images/goods/clothes/4.jpg”,classid:2,hot:863},<br>{keyword:”T恤 黑 白 黑白T恤”,name:”黑白T恤”,”price”:99,imgurl:”/images/goods/clothes/5.jpg”,classid:2,hot:4561},<br>{keyword:”颠覆者 颠覆 书”,name:”颠覆者”,”price”:35,imgurl:”/images/goods/book/dfz.jpg”,classid:3,hot:156},<br>{keyword:”全球通史 全球 书”,name:”全球通史”,”price”:20,imgurl:”/images/goods/book/qqts.jpg”,classid:3,hot:25},<br>{keyword:”世界简史 世界 书”,name:”世界简史”,”price”:156,imgurl:”/images/goods/book/sjjs.jpg”,classid:3,hot:265},<br>{keyword:”行为心理学 行为 书”,name:”行为心理学”,”price”:33,imgurl:”/images/goods/book/xwxlx.jpg”,classid:3,hot:126},<br>{keyword:”美术入门 美术 书”,name:”美术入门”,”price”:155,imgurl:”/images/goods/book/msrm.jpg”,classid:3,hot:565}])</p>
<p>// cars<br>[</p>
<pre><code>{uid,goods:[{goodid,num}]}
</code></pre><p>]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/node3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/node3/" itemprop="url">node3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T12:11:18+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Node第四课"><a href="#Node第四课" class="headerlink" title="Node第四课"></a>Node第四课</h2><blockquote>
<p>Express 框架、模板，MongoDB数据库，小型电商~</p>
</blockquote>
<h4 id="Express-模板"><a href="#Express-模板" class="headerlink" title="Express 模板"></a>Express 模板</h4><p>这是一个用户量较大的一个Node框架，提供了一整套的Node模板，在里面可以使用EJS模板引擎..</p>
<p>基于 Node.js 平台，快速、开放、极简的 web 开发框架。（开发后端）</p>
<p>Express的性能对Node没有影响，依然很高。</p>
<h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><p>安装方法：</p>
<ol>
<li><p>全局安装express 和express应用生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g</span><br><span class="line">npm install express-generator -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用应用生成器去创建应用</p>
</li>
</ol>
<p>-e 代表使用ejs模板引擎，否则会使用jade模板引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd:   express project(项目名字) -e（使用ejs模板引擎）</span><br></pre></td></tr></table></figure>
<ol>
<li>安装依赖，进入到创建好的项目中安装依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd project</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>应用分析：</p>
<ol>
<li><p>package.json</p>
<p> body-parse：专门负责解析前端传递来的数据</p>
<p> cookie-parser：解析请求头中的cookie信息</p>
<p> ejs：模板引擎编译工具</p>
<p> serve-favicon：专门处理类似于谷歌浏览主动请求favicon.ico文件的问题</p>
</li>
<li><p>bin/www 这个是和创建的服务相关的东西，可以在这里配置端口等等设置。</p>
</li>
<li><p>public：静态资源文件夹，在这个文件夹里的文件，在前端都可以直接访问，不需要再在后端配置路由， /stylesheets/a.css</p>
</li>
<li><p>app.js：主应用文件，在这里可以设置路由、插件等等之类的东西，其实创建出来的就是requestListener</p>
</li>
<li><p>views:放入ejs模板，express会将ejs模板装换成html文件</p>
</li>
<li><p>routes:里面的全是路由文件，专门来处理不同的请求</p>
</li>
</ol>
<h5 id="模板引擎："><a href="#模板引擎：" class="headerlink" title="模板引擎："></a>模板引擎：</h5><p>在前端开发过程中，有很多模板引擎可以使用，例如jade，ejs等等，使用模板引擎的优点：</p>
<ol>
<li><p>可以在模板引擎文件里去写一些逻辑性的代码,用于服务端渲染，提高seo优化级别</p>
</li>
<li><p>可以使用便捷语法来开发html结构代码（jade）。</p>
</li>
</ol>
<p>什么是ejs：</p>
<p>ejs是一个简单高效的模板语言，通过数据和模板，可以生成html标记文本，可以说ejs是一个js库，ejs可以运行在客户端和服务器端，客户端安装直接用引入文件即可，服务端要用npm包安装</p>
<ul>
<li><p>ejs的特点：</p>
</li>
<li><p>快速编译和渲染</p>
</li>
<li><p>简单的模板标签</p>
</li>
<li><p>自定义标记分隔符</p>
</li>
<li><p>支持文本包含</p>
</li>
<li><p>支持浏览器端和服务器端</p>
</li>
<li><p>模板静态缓存</p>
</li>
<li><p>支持express视图系统</p>
</li>
</ul>
<h5 id="服务端渲染："><a href="#服务端渲染：" class="headerlink" title="服务端渲染："></a>服务端渲染：</h5><p>其实前端开发需要做的事情，只有两个：1. 创建界面结构 2. 数据交互  3. 渲染数据</p>
<p>数据交互其实又可以分成两种：1. 给后端数据 2. 从后端拿数据</p>
<p>数据交互的目的是什么？取：将数据渲染到dom文档中 给：提交数据到后台后，后台会继续返回我们一个数据，拿到这个数据，依然还是需要渲染</p>
<p>数据渲染方式分为两种：</p>
<ol>
<li><p>客户端渲染（浏览器渲染）：前端js通过ajax等数据交互技术，获取到数据后通过操作dom来进行数据的渲染</p>
<p> 例如，ajax获取到用户购物车的信息，通过拼接字符串的方法将数据渲染在dom中</p>
</li>
<li><p>服务端渲染，浏览器请求到的内容其实可以通过后端加工一下,将一会数据直接渲染好，再给浏览器就可以了</p>
<p> 例如，每个学期开始的时候，学生会得到课本，。课本上的空题都需要学生自己去写，当学期末写完的时候，相当于客户端将数据渲染在浏览器中，学生将答案写在了课本上</p>
<p> 通过，老师都可以得到教材课本，在这种课本上，答案，讲义等等都已经印刷好了，相当于服务端将数据渲染在浏览器，书商将答案印在了课本上</p>
<p> 客户端渲染的优点：比较灵活；经过用户的动作进行加载的数据</p>
<p> 服务端渲染的优点：减少了前端逻辑，提高了SEO优化等级，只要是在页面加载的时候就需要渲染的数据，变动较少的数据</p>
</li>
</ol>
<pre><code>在php中实现服务端渲染：

在php文件中可以放入html代码，访问php文件的时候就相当于访问这个对应的html文件，因为在php文件中，所以可以写一些php的代码来渲染数据

在Node中实现服务端渲染：

利用模板引擎，node在渲染模板的时候给模板传入数据，在模板中就可以使用特定的语法来渲染dom了
</code></pre><hr>
<p>注意：express里的路由是靠请求路径划分的，前一个自己搭的路由是根据请求类型划分的。</p>
<h4 id="MongoDB-数据库"><a href="#MongoDB-数据库" class="headerlink" title="MongoDB 数据库"></a>MongoDB 数据库</h4><p>这是一个数据库，与MySQL(关系型数据库)的区别就是，它是一个非关系型数据库  NoSql数据库</p>
<h5 id="关系型数据库和非关系型数据库的区别"><a href="#关系型数据库和非关系型数据库的区别" class="headerlink" title="关系型数据库和非关系型数据库的区别"></a>关系型数据库和非关系型数据库的区别</h5><p>1.实质。    </p>
<p>非关系型数据库的实质：非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。</p>
<p>2.价格。</p>
<p>目前基本上大部分主流的非关系型数据库都是免费的。而比较有名气的关系型数据库，比如Oracle、DB2、MSSQL是收费的。虽然Mysql免费，但它需要做很多工作才能正式用于生产。</p>
<p>3.功能。    </p>
<p>实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。</p>
<p>mongodb的特点：</p>
<ol>
<li>性能高、I/O处理快</li>
<li>速度快</li>
<li>稳定不好，占用空间大</li>
</ol>
<h4 id="1-安装MongoDB"><a href="#1-安装MongoDB" class="headerlink" title="1.安装MongoDB"></a>1.安装MongoDB</h4><p>下载对应版本的mongodb来进行安装，安装的后注意需要手动设置数据库的位置。。。详细请搜索</p>
<p>1.在安装的时候选择安装地址，一般情况下安装在c盘（默认安装地址）即可</p>
<p>2.我们在c盘（最好）建立一个data文件夹，在data文件夹下面再建立一个db文件夹</p>
<p>3.在mongodb的bin文件夹下，cmd执行 mongod.exe –dbpath c:\data\db</p>
<p>4.运行mongod.exe来启动mongodb</p>
<p>5.依然在mongodb的bin文件夹下cmd 输入mongo回车，就可以操作mongodb，例如 show databases;</p>
<blockquote>
<p>小贴士：如果安装不上，因为有一些个dll文件缺少，要么去按照百度教的方法下载驱动精灵修复系统，要么重装系统，要么就用自己的电脑</p>
</blockquote>
<h4 id="2-MongoDB概念"><a href="#2-MongoDB概念" class="headerlink" title="2.MongoDB概念"></a>2.MongoDB概念</h4><p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>它的特点:高性能、易部署、易使用，存储数据非常方便。</p>
<h4 id="3-专业术语"><a href="#3-专业术语" class="headerlink" title="3.专业术语"></a>3.专业术语</h4><table>
<thead>
<tr>
<th>SQL术语、概念</th>
<th>MongoDB术语、概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表\集合</td>
</tr>
<tr>
<td>row</td>
<td>doucument</td>
<td>数据记录行\文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段\域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td></td>
<td>表连接 mongodb不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键，mongodb自动将_id作为主键</td>
</tr>
</tbody>
</table>
<h4 id="4-mongodb的存储数据类似于js的json格式对象，或者json文件存储数据的方式："><a href="#4-mongodb的存储数据类似于js的json格式对象，或者json文件存储数据的方式：" class="headerlink" title="4.mongodb的存储数据类似于js的json格式对象，或者json文件存储数据的方式："></a>4.mongodb的存储数据类似于js的json格式对象，或者json文件存储数据的方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot;:ObjectId(&quot;1726iuhas678971726731&quot;),</span><br><span class="line">        &quot;age&quot;:25,</span><br><span class="line">        &quot;city&quot;:&quot;beijing&quot;,</span><br><span class="line">        &quot;email&quot;:&quot;asdgakj@qq.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot;:ObjectId(&quot;1726iuhas678971726731&quot;),</span><br><span class="line">        &quot;age&quot;:25,</span><br><span class="line">        &quot;city&quot;:&quot;beijing&quot;,</span><br><span class="line">        &quot;email&quot;:&quot;asdgakj@qq.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5.数据库"></a>5.数据库</h4><p>一个mongodb中可以建立多个数据库。</p>
<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>
<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>
<h4 id="6-简单操作"><a href="#6-简单操作" class="headerlink" title="6.简单操作"></a>6.简单操作</h4><p>show databases 查看数据库</p>
<p>db 查看当前数据库</p>
<p>use name 切换某个数据库</p>
<h4 id="7-文档"><a href="#7-文档" class="headerlink" title="7.文档"></a>7.文档</h4><p>文档是一个键值(key-value)对(即BSON)。</p>
<p>MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。<br>一个简单的文档例子如下：<br>[<br>    {“genres”: [“犯罪”,”剧情” ],”title”: “肖申克的救赎”},<br>    {“title”:”阿甘正传”,grade:”8.4”,”genres”:”励志”}<br>]</p>
<h4 id="8-集合"><a href="#8-集合" class="headerlink" title="8.集合"></a>8.集合</h4><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。</p>
<p>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &apos;title&apos;:[&apos;aaa&apos;,&quot;aaa&quot;,&quot;aaa&quot;,[&quot;a&quot;:&#123;&#125;]]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &apos;title&apos;:&apos;bbb&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-数据类型"><a href="#9-数据类型" class="headerlink" title="9.数据类型"></a>9.数据类型</h4><p>String : 这是最常用的数据类型来存储数据。在MongoDB中的字符串必须是有效的UTF-8。</p>
<p>Integer : 这种类型是用来存储一个数值。整数可以是32位或64位，这取决于您的服务器。</p>
<p>Boolean : 此类型用于存储一个布尔值 (true/ false) 。</p>
<p>Double : 这种类型是用来存储浮点值。</p>
<p>Min/ Max keys : 这种类型被用来对BSON元素的最低和最高值比较。</p>
<p>Arrays : 使用此类型的数组或列表或多个值存储到一个键。</p>
<p>Timestamp : 时间戳。这可以方便记录时的文件已被修改或添加。</p>
<p>Object : 此数据类型用于嵌入式的文件。</p>
<p>Null : 这种类型是用来存储一个Null值。</p>
<p>Symbol : 此数据类型用于字符串相同，但它通常是保留给特定符号类型的语言使用。</p>
<p>Date : 此数据类型用于存储当前日期或时间的UNIX时间格式。可以指定自己的日期和时间，日期和年，月，日到创建对象。</p>
<p>Object ID : 此数据类型用于存储文档的ID。</p>
<p>Binary data : 此数据类型用于存储二进制数据。</p>
<p>Code : 此数据类型用于存储到文档中的JavaScript代码。</p>
<p>Regular expression : 此数据类型用于存储正则表达式</p>
<h4 id="10-库的操作"><a href="#10-库的操作" class="headerlink" title="10.库的操作"></a>10.库的操作</h4><ul>
<li>Help查看命令提示</li>
</ul>
<p>help</p>
<p>db.help()</p>
<p>db.test.help()</p>
<p>db.test.find().help()</p>
<ul>
<li>创建/切换数据库</li>
</ul>
<p>use music</p>
<ul>
<li>查询数据库</li>
</ul>
<p>show dbs 空库将不会显示</p>
<p>db.albums.insertOne({‘title’:’bey bey’})来插入一条后再看</p>
<ul>
<li>查看当前使用的数据库</li>
</ul>
<p>db/db.getName()</p>
<ul>
<li>显示当前DB状态</li>
</ul>
<p>db.stats()</p>
<ul>
<li>查看当前DB版本</li>
</ul>
<p>db.version()</p>
<ul>
<li>查看当前DB的链接机器地址</li>
</ul>
<p>db.getMongo()</p>
<ul>
<li>删除数据库</li>
</ul>
<p>db.dropDatabase()</p>
<h4 id="Collection聚集集合操作"><a href="#Collection聚集集合操作" class="headerlink" title="Collection聚集集合操作"></a>Collection聚集集合操作</h4><p>创建一个聚集集合</p>
<p>db.createCollection(“collName”, {size（集合大小）: 20, capped（固定大小，可提高使用效率）: true, max（最大值）: 100});</p>
<p>db.collName.isCapped(); //判断集合是否为定容量</p>
<p>得到指定名称的聚集集合</p>
<p>db.getCollection(“account”);</p>
<p>得到当前db的所有聚集集合</p>
<p>db.getCollectionNames();</p>
<p>显示当前db所有聚集的状态</p>
<p>db.printCollectionStats();</p>
<h3 id="添加、修改与删除集合数据"><a href="#添加、修改与删除集合数据" class="headerlink" title="添加、修改与删除集合数据"></a>添加、修改与删除集合数据</h3><p>查看</p>
<p>db.users.find()</p>
<p>添加</p>
<p>db.users.save({name: ‘zhangsan’, age: 25, sex: true});</p>
<p>db.users.insertOne({name: ‘zhangsan’, age: 25, sex: true});</p>
<p>db.users.insertMany([{name: ‘zhangsan’, age: 25, sex: true},{name: ‘zhangsan’, age: 25, sex: true}]);</p>
<p>修改</p>
<p>db.users.update({age: 25}(约定条件，全部修改只写{}), {$set: {name: ‘changeName’,sex:1}}, false, true);</p>
<p>第三个参数为，如果没有这个数据，会不会创建，第四个参数为，如果有很多，是要全改true，还是只改第一条</p>
<p>相当于：update users set name = ‘changeName’ where age = 25;</p>
<p>db.users.update({name: ‘Lisi’}, {$inc: {age: 50}}, false, true);</p>
<p>相当于：update users set age = age + 50 where name = ‘Lisi’;</p>
<p>db.users.update({name: ‘Lisi’}, {$inc: {age: 50}, $set: {name: ‘hoho’}}, false, true);</p>
<p>相当于：update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’;</p>
<p>删除</p>
<p>db.users.remove({age: 32});符合条件全删<br>db.users.remove({age: 132}，{justone:true});只删一条<br>db.users.remove({});删除所有document</p>
<p>查询修改删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.users.findAndModify(&#123;</span><br><span class="line">    query: &#123;age: &#123;$gte: 25&#125;&#125;, </span><br><span class="line">    sort: &#123;age: -1&#125;, </span><br><span class="line">    update: &#123;$set: &#123;name: &apos;a2&apos;&#125;, $inc: &#123;age: 2&#125;&#125;,</span><br><span class="line">    remove: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.runCommand(&#123; findandmodify : &quot;users&quot;, </span><br><span class="line">    query: &#123;age: &#123;$gte: 25&#125;&#125;, </span><br><span class="line">    sort: &#123;age: -1&#125;, </span><br><span class="line">    update: &#123;$set: &#123;name: &apos;a2&apos;&#125;, $inc: &#123;age: 2&#125;&#125;,</span><br><span class="line">    remove: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>query 过滤条件 $gte大于</p>
<p>sort如果多个文档符合查询过滤条件，将以该参数指定的排列方式选择出排在首位的对象，该对象将被操作，-1位为降序</p>
<p>remove 若为true，被选中对象将在返回前被删除</p>
<p>update 一个 修改器对象</p>
<p>remove 创建新对象若查询结果为空</p>
<h4 id="聚集集合查询"><a href="#聚集集合查询" class="headerlink" title="聚集集合查询"></a>聚集集合查询</h4><p>查询所有记录</p>
<p>db.userInfo.find();</p>
<p>相当于：select* from userInfo;</p>
<p>查询去重后数据</p>
<p>db.userInfo.distinct(“name”);</p>
<p>相当于：select distict name from userInfo;</p>
<p>查询age = 22的记录</p>
<p>db.userInfo.find({“age”: 22});</p>
<p>相当于： select * from userInfo where age = 22;</p>
<p>查询age &gt; 22的记录</p>
<p>db.userInfo.find({age: {$gt: 22}});</p>
<p>相当于：select * from userInfo where age &gt;22;</p>
<p>查询age &lt; 22的记录</p>
<p>db.userInfo.find({age: {$lt: 22}});</p>
<p>相当于：select * from userInfo where age &lt;22;</p>
<p>查询age &gt;= 25的记录</p>
<p>db.userInfo.find({age: {$gte: 25}});</p>
<p>相当于：select * from userInfo where age &gt;= 25;</p>
<p>查询age &lt;= 25的记录</p>
<p>db.userInfo.find({age: {$lte: 25}});</p>
<p>查询age &gt;= 23 并且 age &lt;= 26</p>
<p>db.userInfo.find({age: {$gte: 23, $lte: 26}});</p>
<p>查询name中包含 mongo的数据</p>
<p>db.userInfo.find({name: /^mongo/});</p>
<p>//相当于%%<br>select * from userInfo where name like ‘%mongo%’;</p>
<p>查询name中以mongo开头的</p>
<p>db.userInfo.find({name: /^mongo/});</p>
<p>相当于select * from userInfo where name like ‘mongo%’;</p>
<p>查询指定列name、age数据</p>
<p>db.userInfo.find({}, {name: 1, age: 1});</p>
<p>相当于：select name, age from userInfo;</p>
<p>查询指定列name、age数据, age &gt; 25</p>
<p>db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1});</p>
<p>相当于：select name, age from userInfo where age &gt;25;</p>
<p>按照年龄排序</p>
<p>升序：db.userInfo.find().sort({age: 1});</p>
<p>降序：db.userInfo.find().sort({age: -1});</p>
<p>查询name = zhangsan, age = 22的数据</p>
<p>db.userInfo.find({name: ‘zhangsan’, age: 22});</p>
<p>相当于：select * from userInfo where name = ‘zhangsan’ and age =<br>’22’;</p>
<p>查询前5条数据</p>
<p>db.userInfo.find().limit(5);</p>
<p>相当于：select top 5 * from userInfo;</p>
<p>查询10条以后的数据</p>
<p>db.userInfo.find().skip(10);</p>
<p>相当于：select <em> from userInfo where id not in (<br>   select top 10 </em> from userInfo<br>);</p>
<p>查询在5-10之间的数据</p>
<p>db.userInfo.find().limit(10).skip(5);</p>
<p>or与 查询</p>
<p>db.userInfo.find({$or: [{age: 22}, {age: 25}]});</p>
<p>相当于：select * from userInfo where age = 22 or age = 25;</p>
<p>查询第一条数据</p>
<p>db.userInfo.findOne();</p>
<p>相当于：selecttop 1 * from userInfo;</p>
<p>db.userInfo.find().limit(1);</p>
<p>查询某个结果集的记录条数</p>
<p>db.userInfo.find({age: {$gte: 25}}).count();</p>
<p>相当于：select count(*) from userInfo where age &gt;= 20;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/node2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/node2/" itemprop="url">node2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T12:03:39+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Node第三课"><a href="#Node第三课" class="headerlink" title="Node第三课"></a>Node第三课</h3><blockquote>
<p>搭建web服务器，并实现后端路由结构</p>
<h4 id="了解web应用里前后端的关系"><a href="#了解web应用里前后端的关系" class="headerlink" title="了解web应用里前后端的关系"></a>了解web应用里前后端的关系</h4><p>大部分的web应用都是会分开前后端来进行开发的，前端开发静态页面、与后端进行的数据逻辑交互，后端负责搭建后端服务器，给前端提供接口<br>开发完成后，一般会将前端页面放入到后端服务器中，用户通过浏览器访问服务器来得到前端界面显示在用户的浏览器中就可以使用了</p>
<h4 id="如何来实现一个web应用"><a href="#如何来实现一个web应用" class="headerlink" title="如何来实现一个web应用"></a>如何来实现一个web应用</h4><ol>
<li>作为前端工程师，应该开发一套前端的页面，借助BootStrap前端框架来快速搭建。</li>
<li>后端工程师拿到前端开发的项目后放入服务器目录下</li>
<li>后端搭建服务器<br> 因为用户在访问到页面内容后会解析页面结构如果有css、js、image请求的话，会再次发送请求，这个时候requestListener函数会再次的执行，所以后端应该根据前端请求的内容，做出不同的响应，这就是后端路由的工作<br> 首先，前端的请求，大致分成2种请求：资源请求（请求图片、css、js等资源文件）、数据请求（通过ajax、fetch等方法进行的数据交互）<br> 资源请求的响应方式：解析前端的请求内容，找到对应的文件，返回给前端<br> 其实主要需要设置的部分，在requestListener里，因为每当客户端发送请求的时候，这个函数都会执行吗，并且接收一些请求信息，后端路由可以依次来进行判断，然后做出响应</li>
</ol>
</blockquote>
<pre><code>所以，当前的第一步，准备将请求分流
1. 先将requestListener封装成router模块,并且可以对资源请求进行分流，处理资源请求，处理404返回内容，使用mime模块对资源问题的Content-Type做了处理
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//server.js</span><br><span class="line">const router = require(&apos;./router&apos;)</span><br><span class="line">const server = http.createServer(router)</span><br><span class="line">//...</span><br><span class="line">//router/index.js</span><br><span class="line">//专门处理资源请求的模块</span><br><span class="line">const source = require(&apos;./source&apos;)</span><br><span class="line">const not_found = require(&apos;./not_found&apos;)//404</span><br><span class="line">const router = (req,res)=&gt;&#123;//requestListener函数，在这里分流资源请求ヘ数据请求，然后分别使用不同的工具来进行处理</span><br><span class="line">    //因为有时候进入首页请求的直接就是域，req.url就是一个/</span><br><span class="line">    req.url = req.url==&apos;/&apos;?&apos;/static/html/index.html&apos;:req.url         </span><br><span class="line">    if(req.url.indexOf(&apos;/static&apos;)==0)&#123;//资源请求</span><br><span class="line">        source.handler(req,res)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //现有的路由规则无法匹配，返回404</span><br><span class="line">        not_found.handler(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = router</span><br><span class="line">//...</span><br><span class="line">//router/source.js //专门处理资源请求</span><br><span class="line">const source = &#123;</span><br><span class="line">    handler(req,res)&#123;//处理资源请求</span><br><span class="line">        //判断请求对应的资源存在之后，读取内容，做出响应，不存在的话，返回404</span><br><span class="line">        let source_path = &apos;.&apos;+req.url</span><br><span class="line">        fs.stat(source_path,err=&gt;&#123;</span><br><span class="line">            if(err)&#123;</span><br><span class="line">                //代表资源不存在...需要返回404</span><br><span class="line">                not_found.handler(res)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //资源存在，读取资源，然后返回</span><br><span class="line">                let content = fs.readFileSync(source_path)</span><br><span class="line">                res.writeHead(200,&#123;&apos;Content-Type&apos;:mime.getType(source_path)&#125;)</span><br><span class="line">                res.end(content)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = source</span><br><span class="line">//...</span><br><span class="line">// router/not_found.js 专门处理404返回内容</span><br><span class="line">const not_found = &#123;</span><br><span class="line">    handler(res)&#123;</span><br><span class="line">        let content = fs.readFileSync(&quot;./static/html/404.html&quot;)</span><br><span class="line">        res.writeHead(404,&#123;&quot;Content-Type&quot;:&apos;text/html;charset=utf8&apos;&#125;)</span><br><span class="line">        res.end(content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = not_found</span><br></pre></td></tr></table></figure>
</code></pre><h5 id="mime模块的使用"><a href="#mime模块的使用" class="headerlink" title="mime模块的使用"></a>mime模块的使用</h5><p>因为在node服务器中，返回响应内容的时候经常需要对响应头（response header）进行配置，例如Content-Type选项就至关重要，浏览器会根据Content-Type来对请求到的资源解析，可以利用mime模块来解析文件资源的mime type类型，使用方法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const mime = require(&apos;mime&apos;)</span><br><span class="line">mime.lookup(&apos;a/b/c.css&apos;)  // text/css ,以前版本的，新版本的方法改为了getType</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.cnblogs.com/jeacy/p/6992435.html" target="_blank" rel="noopener">旧版本中文教程</a><br><a href="https://github.com/broofa/node-mime" target="_blank" rel="noopener">github文档资源</a></p>
<h5 id="使用supervisor来进行热更新"><a href="#使用supervisor来进行热更新" class="headerlink" title="使用supervisor来进行热更新"></a>使用supervisor来进行热更新</h5><p>在开发中如果我们修改了js文件，或是调试功能，或是增加功能。这时需要重新启动该服务，每次修改都需要执行以下两步：</p>
<ol>
<li>ctrl+c  打断当前运行状态</li>
<li>node server.js 重新启动<br>现在可以利用supervisor工具来启动项目，当项目文件更改后会自动更新，或者执行rs就会重新启动<br>先要全局安装supervisor  npm/cnpm install -g/–global supervisor<br>node server.js -&gt; supervisor server.js<h5 id="关于package-json里的scripts（npm-scripts）"><a href="#关于package-json里的scripts（npm-scripts）" class="headerlink" title="关于package.json里的scripts（npm scripts）"></a>关于package.json里的scripts（npm scripts）</h5>我们可以在package.json里的scripts配置项中设置一些快捷操作，例如 ‘start’:’node server.js’这个时候就可以通过执行npm run start来执行这个命令,且如果配置的键名为start的时候可以直接执行npm start；</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/node1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/node1/" itemprop="url">node1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T11:42:21+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前端开发的工具"><a href="#前端开发的工具" class="headerlink" title="前端开发的工具"></a>前端开发的工具</h2><h3 id="编辑器："><a href="#编辑器：" class="headerlink" title="编辑器："></a>编辑器：</h3><ol>
<li>轻量级的，依靠插件：sublime；atom（github）；vs code（miscrosaft）</li>
<li>集成的：DW；webstorm；hbuild；</li>
</ol>
<hr>
<h3 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h3><p>markdown是一个标记语言，可以利用一些简单的语法来对内容进行排版，可以将markdown文件编译成html，pdf，一般使用markdown写笔记、文档…</p>
<p>eq：一般的项目中都会README.md文件来做项目标识。</p>
<p>一般的编辑器都可以编写markdown，语法简单，也有专门的markdown编辑器</p>
<h4 id="使用gulp搭建markdown编译环境"><a href="#使用gulp搭建markdown编译环境" class="headerlink" title="使用gulp搭建markdown编译环境"></a>使用gulp搭建markdown编译环境</h4><ol>
<li><p>执行npm init 进行项目初始化得到package.json</p>
</li>
<li><p>全局安装gulp ：npm install gulp –global;</p>
</li>
<li><p>在项目中安装gulp依赖：npm install gulp –save-dev;</p>
</li>
<li><p>创建gulpfile.js文件设置任务：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&quot;gulp&quot;)</span><br><span class="line">var markdown = require(&apos;gulp-markdown&apos;);</span><br><span class="line">var mdpdf = require(&apos;gulp-markdown-pdf&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gulp.task(&quot;compileMDToHtml&quot;,function () &#123;</span><br><span class="line">    gulp.src(&quot;./md/*.md&quot;)</span><br><span class="line">        .pipe(markdown())</span><br><span class="line">        .pipe(gulp.dest(&quot;./html&quot;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;compileMDToPdf&quot;,function () &#123;</span><br><span class="line">    gulp.src(&quot;./md/*.md&quot;)</span><br><span class="line">        .pipe(mdpdf())</span><br><span class="line">        .pipe(gulp.dest(&quot;./pdf&quot;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;watch:md&quot;,function()&#123;</span><br><span class="line">    gulp.watch(&quot;./md/*.md&quot;,[&apos;compileMDToHtml&apos;,&apos;compileMDToPdf&apos;])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;default&quot;,[&apos;compileMDToHtml&apos;,&apos;compileMDToPdf&apos;,&apos;watch:md&apos;])</span><br></pre></td></tr></table></figure>
<ol>
<li>在命令行工具通过执行gulp指令来运行gulp中的默认任务</li>
</ol>
<h4 id="markdown的简单语法"><a href="#markdown的简单语法" class="headerlink" title="markdown的简单语法"></a>markdown的简单语法</h4><p><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="noopener">入门连接，来自简书</a></p>
<hr>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><blockquote>
<p>一个后端技术，研究web应用的开发模式…，希望能有能力开发一些简单的web服务器，学会操作数据库等等。</p>
</blockquote>
<h3 id="NodeJS第一课"><a href="#NodeJS第一课" class="headerlink" title="NodeJS第一课"></a>NodeJS第一课</h3><h5 id="什么是nodeJs"><a href="#什么是nodeJs" class="headerlink" title="什么是nodeJs"></a>什么是nodeJs</h5><p>下面是对官网描述的解析：</p>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</p>
<blockquote>
<p>在Node里面写JS代码，很开心~~，为什么基于引擎：在web前端中，js运行在浏览器中，js只是一个脚本语言，js文件也只是一个普通的文本文件，只有在浏览器中才能发挥应有的作用。浏览器内部有一个东西叫做内核，浏览器内核的类型：<br>IE ：trident/microsoft/ms;chrome:blink(webkit)/google/webkit;firefox:gecko/mozillar/moz;opera:blink(presto)/opera/o; safari：webkit/apple/webkit<br>内核里有两个东西：渲染引擎（渲染DOM结构，CSS）、脚本引擎（编译执行JS代码）</p>
</blockquote>
<p>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其++轻量++又++高效++。</p>
<blockquote>
<p>NodeJS的优点：轻量、高效</p>
</blockquote>
<p>node是使用C++编写的基于V8引擎的JS运行环境，同时提供了很多基于ECMAScript的扩展对象。</p>
<blockquote>
<p>node的底层语言是C++,JS是netscope公司创造出来的，诞生的目的是：在前端做表单验证；netscope将js交给ECMA国际标准组织-&gt;ECMAScript 1.0;<br>ECMAScript是JS的语法规范；所以说：NODEjs里的js语法和浏览器的语法是一样的。且多出了很多对象；</p>
</blockquote>
<p>Node.js 的包管理器 npm，成为世界上最大的开放源代码的生态系统。</p>
<blockquote>
<p>npm是Node的一个小兄弟,会在安装Node的时候一起安装，node package manager；<a href="www.npmjs.com">npmjs</a>这个网站上有很多很多的node的工具包来使用，免费的包就有470000+，一般需求的包都可以在这里找到</p>
</blockquote>
<hr>
<h5 id="NodeJS可以干什么？"><a href="#NodeJS可以干什么？" class="headerlink" title="NodeJS可以干什么？"></a>NodeJS可以干什么？</h5><p>Node.js 可以解析JS代码（没有浏览器安全级别的限制）提供很多系统级别的API，如：</p>
<blockquote>
<p>浏览器运行JS的时候，例如AJAX，因为浏览器有同源策略，所以会出现跨域问题，这就是浏览器安全限制<br>浏览器端js不能操作文件系统，但是在NodeJs里就可以</p>
</blockquote>
<ul>
<li>文件的读写</li>
<li>进程的管理</li>
<li>网络通信</li>
<li>…</li>
</ul>
<p>nodejs可以编写独立的服务端应用，也可以向客户端提供Web内容，无需借助与任何Web服务器（apache）可以去连接文件系统，还能操作数据库。</p>
<blockquote>
<p>证明Node完全可以作为后端服务器的开发工具<br>一般的应用分为两种架构：B/S(browser/server);C/S(client/server)<br>服务器的外观上的话是千奇百怪的，内部分为逻辑层（JS-NODE,PHP-APACHE,JAVA-VM）、资源层(文件系统，数据库)</p>
</blockquote>
<p>是Node选择了JS，还是JS选择了Node？</p>
<p>是Node选择了JS，因为JS的受众较广，且JS的特性和Node的理念较为符合..</p>
<hr>
<h5 id="为什么要学习nodeJs"><a href="#为什么要学习nodeJs" class="headerlink" title="为什么要学习nodeJs"></a>为什么要学习nodeJs</h5><p>对于咱们来说，一种语言通吃前后端，并且可以增加咱们的竞争力</p>
<p>且Node现在较火，它有如下的特点：</p>
<p>==nodejs适合高并发、I/O密集型，可伸缩的网路应用，数据写入读取的应用比较好==</p>
<blockquote>
<p>I/O输入输出频繁的应用就是I/O密集型</p>
</blockquote>
<p>==nodejs不适合CPU密集型的应用，各种计算的就不太适合==</p>
<blockquote>
<p>CPU密集型应用，一般计算量特别的大！</p>
</blockquote>
<p>==nodej间服务器：==s适合开发中</p>
<h2 id="gt-将高并发的，I-O密集操作交由Node服务器来处理，Node服务器再向真正的Web服务器发送请求得到响应后返回给前端"><a href="#gt-将高并发的，I-O密集操作交由Node服务器来处理，Node服务器再向真正的Web服务器发送请求得到响应后返回给前端" class="headerlink" title="&gt; 将高并发的，I/O密集操作交由Node服务器来处理，Node服务器再向真正的Web服务器发送请求得到响应后返回给前端"></a>&gt; 将高并发的，I/O密集操作交由Node服务器来处理，Node服务器再向真正的Web服务器发送请求得到响应后返回给前端</h2><h5 id="nodeJs-学习网站"><a href="#nodeJs-学习网站" class="headerlink" title="nodeJs 学习网站"></a>nodeJs 学习网站</h5><ol>
<li><a href="https://nodejs.org/" target="_blank" rel="noopener">nodejs官网</a></li>
</ol>
<p>我们可以在这里下载node，查看api，版本更新日志等动态</p>
<ol>
<li><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm官网</a></li>
</ol>
<p>我们可以在这这里查找很多很多的node模块去学习</p>
<ol>
<li><p><a href="https://github.com/" target="_blank" rel="noopener">github官网</a></p>
</li>
<li><p><a href="http://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a></p>
</li>
<li><p><a href="https://juejin.im/" target="_blank" rel="noopener">掘金</a>;<a href="https://segmentfault.com" target="_blank" rel="noopener">sgmentFault</a></p>
</li>
<li><p><a href="http://wiki.jikexueyuan.com/project/nodejs/" target="_blank" rel="noopener">极客学院node文档</a></p>
</li>
</ol>
<hr>
<h5 id="nodeJs安装"><a href="#nodeJs安装" class="headerlink" title="nodeJs安装"></a>nodeJs安装</h5><p>nodeJs版本：</p>
<p>LTS指的是long time support 也就是长期支持版本，推荐大家安装</p>
<p>Current是现在最新的版本。</p>
<p>请安装到C盘吧，它占用的内存不是很大，不会卡，否则需要配置全局变量才可以在任意一个盘下使用。</p>
<hr>
<h5 id="搭建第一个node服务器"><a href="#搭建第一个node服务器" class="headerlink" title="搭建第一个node服务器"></a>搭建第一个node服务器</h5><p>我们在项目目录下建立一个server.js文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;)</span><br><span class="line"></span><br><span class="line">const port = 3000</span><br><span class="line"></span><br><span class="line">const hostname = &apos;127.0.0.1&apos;</span><br><span class="line"></span><br><span class="line">const server = http.createServer((req,res)=&gt;&#123;</span><br><span class="line">    res.end(&apos;hai hai is handsome&apos;)</span><br><span class="line">&#125;).listen(port,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;server is listening&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样的话只要运行后，客户端访问这个服务器的时候就可以接收到响应的信息</p>
<p>在控制台里输入node 文件名+回车（脚本模式），这时，我们的服务就启动了</p>
<p>这只是一个简单的例子，里面的代码我们后面都会详细再介绍</p>
<hr>
<h5 id="NodeJS运行JS代码的方式"><a href="#NodeJS运行JS代码的方式" class="headerlink" title="NodeJS运行JS代码的方式"></a>NodeJS运行JS代码的方式</h5><ol>
<li>脚本模式：在命令行里执行 node 文件名（不需要加后缀名） + enter就可以运行脚本文件中的js代码了。</li>
</ol>
<blockquote>
<p>如果是js文件的话，不需要加后缀名，如果是其他后缀名的话必须得加</p>
</blockquote>
<ol>
<li>REPL模式:在命令行中输入node后回车，大家会发现这个时候我们的控制台就像chrome浏览器里一样可以运行js代码了，其实这里就是node离的V8引擎解析js代码的情况。模式是读一句返回一句。</li>
</ol>
<p>注意，在Node里运行alert会报错：alert is not define,原因是：</p>
<p>alert是属于window对象的一个方法，window属于BOM对象，BOM、DOM属于宿主对象，在web前端JS中，浏览器就是JS的宿主，所以BOM/DOM是JS在浏览器中的宿主对象，在Node中，Node就是JS的宿主，Node的宿主对象可没有BOM/DOM，更没有window了。</p>
<p>比如process对象、global(角色定位相当于window对象)对象在浏览器里就没有</p>
<hr>
<h5 id="关于请求的面试题"><a href="#关于请求的面试题" class="headerlink" title="关于请求的面试题"></a>关于请求的面试题</h5><p>当浏览器地址栏输入www.baidu.com，敲下回车会发生什么？</p>
<ol>
<li><p>利用DNS域名解析系统进行域名解析，将域名解析成IP</p>
<p> 因为域名只是一个别名，计算机只认识IP，所以需要DNS解析一下</p>
</li>
<li><p>查找ip对应的主机服务器</p>
<p> 如果是第一次访问该服务器，会向网络供应商（移动、联通…）请求</p>
</li>
<li><p>TCP的三次握手，经过三次在客户端和服务器之间传递报文，建立连接</p>
</li>
<li><p>发起http请求，请求入口文件，后端接收到请求相关信息，返回入口文件</p>
</li>
<li><p>解析入口文件，同时如果有资源请求继续发送http请求…</p>
</li>
<li><p>入口文件渲染完成（TCP的四次挥手，断开连接）</p>
</li>
</ol>
<hr>
<h5 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h5><p>现在我们来创建一个hello.js文件</p>
<blockquote>
<p>ES6小知识：const可以定义只读常量readonly，let定义局部变量，只有用了这两个，就会形成块级作用域。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 引入http模块   说明Node给咱们内置了很多模块 </span><br><span class="line">const http = require(&quot;http&quot;)</span><br><span class="line">//定义端口</span><br><span class="line">const port = 3000</span><br><span class="line">//定义域名信息 10.9.166.65</span><br><span class="line">// 假设有一个大商城（服务器主机），商城里有很多商店（主机里可能有很多服务器），每一个商店都有自己的一个入口A1,A2(每一个服务器都有一个端口)，大商场可能也有一些名字（域名或者IP）</span><br><span class="line"></span><br><span class="line">// 域名和IP：域名只是为了方便用户记忆，真正计算机识别的是IP，每一个网段主机都会拥有一个ip，</span><br><span class="line">// 127.0.0.1回环地址对应的域名是localhost,每个主机访问此地址的时候都是访问到的自己</span><br><span class="line"></span><br><span class="line">const host = &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">//创建服务（服务员） 传入requestListener函数，当有客户端访问的时候就会执行</span><br><span class="line">// req上保存的是此次访问的请求相关信息，一般用来做判断...</span><br><span class="line">//res是专门做出响应的工具，有writeHead方法，statusCode属性，setHeader方法，write方法，end方法</span><br><span class="line">const server = http.createServer((req,res)=&gt;&#123;</span><br><span class="line">    console.log(req.url)//此次请求的地址,得到的就是整个请求地址中，域名端口后面的path路径</span><br><span class="line">    console.log(req.method)//此次请求的方法</span><br><span class="line">    console.log(req.headers)//此次请求的请求头信息例如cookie</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // res.statusCode=200//设置响应的状态码，为浏览器而设置，200成功 404</span><br><span class="line">    // res.setHeader(&quot;Content-Type&quot;,&quot;text/plain;charset=utf8&quot;)//设置响应头</span><br><span class="line">    //content-type特别重要，告诉浏览器我给你返回的是什么东西，text/plain普通纯文本,text/html,text/css,application/javascript</span><br><span class="line">    </span><br><span class="line">    // res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=utf8&apos;&#125;)//是res.statusCode和res.setHeader的简写方式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // res.write(&apos;海海帅吗？&lt;br/&gt;&apos;) //写入响应内容，可以执行多次,只能写字符串</span><br><span class="line">    // res.write(&apos;帅&apos;) </span><br><span class="line"></span><br><span class="line">    // res.end(&apos;!!!&apos;)//通知前端响应结束,其实在end里也可以写入响应内容,但是end之后不能再write</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=utf8&apos;&#125;)</span><br><span class="line"></span><br><span class="line">    if(req.url==&apos;/question&apos;)&#123;</span><br><span class="line">        res.end(Math.random()&lt;0.8?&apos;帅&apos;:&apos;还行吧&apos;)</span><br><span class="line">    &#125;else if(req.url==&apos;/random&apos;)&#123;</span><br><span class="line">        res.end(Math.random()+&apos;&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.end(&apos;&lt;a href=&quot;http://10.9.166.65:3000/question&quot;&gt;看看海海帅不帅&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://10.9.166.65:3000/random&quot;&gt;来一个随机数&lt;/a&gt;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">//监听端口域名，跑起服务</span><br><span class="line">server.listen(port,host,()=&gt;&#123;</span><br><span class="line">    //会在监听之后触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="回调函数小知识"><a href="#回调函数小知识" class="headerlink" title="回调函数小知识"></a>回调函数小知识</h5><p>将一个函数作为另一个函数的参数或者对象的属性值，这样的函数就是回调函数</p>
<p>特点： 在某一个特定的时刻触发</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    success:function()&#123;</span><br><span class="line">        alert(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h5 id="模块化及在Node中的应用"><a href="#模块化及在Node中的应用" class="headerlink" title="模块化及在Node中的应用"></a>模块化及在Node中的应用</h5><p>什么是模块化？</p>
<p>将系统功能分离成独立的功能部分的方法就是模块化。目的、优点：代码复用，便于维护！（八字金言，基本上百分之八十的技术点的优点都可以用这八个字概括）</p>
<p>在生活中，假设有这样的场景：</p>
<p>现在我们需要做一个雕像：变型金刚。有两种方式：1. 直接在大的材料上进行雕刻 2.分开部分来雕刻最后再组装到一起；</p>
<p>一般都会使用第二种方式，因为第二种有这样的优点：1. 便于分工合作 2. 便于复用 3. 便于维护（因为复用了，一改都改；因为每一个模块都是独立的，便于修改）</p>
<p>模块划分的原则：1. 此功能被复用次数较多 2. 此功能的逻辑较为独立</p>
<p>模块应该具有的特性： </p>
<ol>
<li><p>内聚度：模块的独立性，越高越好；</p>
<p> 例如，海贼王里每一个角色都有自己独立的支线故事，他们的内聚度高</p>
</li>
<li><p>耦合度：模块与模块间的关系，越低越好；</p>
<p> 例如：葫芦娃里的七个娃，一个被抓，全军覆没，耦合度较高。</p>
</li>
</ol>
<p>模块化的规范：</p>
<pre><code>在开发变形金刚的时候，每一个部分最后都要连接到一起，所以需要规定一些连接的相关规则，比如，螺钉的长宽高，螺孔的长宽高。螺钉的作用是为了此模块可以导入到其他模块中，螺孔的作用是可以将其他模块导入进来，也就说，模块化的规范其实就是规定螺钉ヘ螺孔的相关信息，其实也就说：

如何导入模块，和如何导出模块
</code></pre><p>现有的几种模块化规范：</p>
<pre><code>| 现有的规范     | AMD           | CMD    |CommonJS  |ES6 module  |
| ------------- |:-------------:| :-----:| :-------:| ----------:|
| 使用场景      | 前端 | 前端  |后端Node |前后端都行（需要编译）|
| 工具或环境      | requierJs      |   SeaJs  |Node |在js引擎里 |
| 同异步 | 异步（async module define 异步模块定义）   | 同步，延迟加载 （commond module define 通用模块定义） |同步 |同步|

AMD是requirejs工具里定义的模块化规范，requireJS在推广的过程中对自己的模块化规范命名为AMD，异步导入模块，运行于浏览器端，不会阻塞页面加载：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//利用define函数来导出模块，可以通过require函数导入模块（同步，不建议使用），在define函数的i一个参数数组里也可以指定需要导入的模块,提前加载</span><br><span class="line"></span><br><span class="line">var c = require(&apos;c&apos;)</span><br><span class="line">console.log(c)</span><br><span class="line">define([&apos;a&apos;,&apos;b&apos;],function(a,b)&#123;</span><br><span class="line">    console.log(a,b)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1)</span><br></pre></td></tr></table></figure>

CMD是seaJS工具里定义的模块化规范，同步但是延迟导入模块，也不会阻塞，as lazy as possible

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//b模块</span><br><span class="line">define(function()&#123;</span><br><span class="line">    var a = require(&apos;a&apos;)</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

CommonJS是Node的模块化规范，它是同步导入模块，因为node的模块都是本地的，所以模块的加载速度等于硬盘的读取速度，不会阻塞代码的运行
</code></pre><h5 id="CommonJS的模块化与使用"><a href="#CommonJS的模块化与使用" class="headerlink" title="CommonJS的模块化与使用"></a>CommonJS的模块化与使用</h5><pre><code>CommonJS导入模块的方式是：

1. 使用require方法，传入目标模块的路径，返回值为模块导出的内容

注意:

模块导入之后，模块内的代码会执行一次，

模块里的变量、函数都是私有的。如果需要使用，必须得在模块中导出

默认的模块导出的是module.exports这个对象，这是一个空对象

代码：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//math.js      </span><br><span class="line">const math = &#123;</span><br><span class="line">    add(num1,num2)&#123;</span><br><span class="line">        return num1+num2</span><br><span class="line">    &#125;,</span><br><span class="line">    reduce(num1,num2)&#123;</span><br><span class="line">        return num1-num2</span><br><span class="line">    &#125;,</span><br><span class="line">    mutiply(num1,num2)&#123;</span><br><span class="line">        return num1*num2</span><br><span class="line">    &#125;,</span><br><span class="line">    divide(num1,num2)&#123;</span><br><span class="line">        return num1/num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = math</span><br><span class="line">// module.exports.math=math</span><br><span class="line">// module.exports.add = math.add</span><br><span class="line">// module.exports.reduce = math.reduce</span><br><span class="line">// module.exports.mutiply = math.mutiply</span><br><span class="line">// module.exports.divide = math.divide</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">const math = require(&apos;./modules/math&apos;)</span><br><span class="line">console.log(math.divide(6,2))</span><br></pre></td></tr></table></figure>

2. 可以把一个大模块做成一个目录，直接引入这个目录名相当于导入的是目录里的入口文件，默认情况入口文件是index.js,如果目录中存在package.json的话，json文件中配置的main选项的文件就是入口文件。

    如果此目录在node_modules文件夹中的话，不需要写路径
</code></pre><hr>
<h5 id="NPM使用入门"><a href="#NPM使用入门" class="headerlink" title="NPM使用入门"></a>NPM使用入门</h5><p>npm 就是node package manager node的包管理工具</p>
<p>我们通过npm install 模块 来安装模块，缩写：npm i 模块,注意，低版本的node可能需要npm init先来创建一个package.json文件，这也是我推荐的,默认的会安装到目录中的node_modules；如果没有这个文件夹，会自动创建</p>
<p>卸载的话就是unintsall</p>
<p>全局安装（大多是工具，例如gulp等） -g（全写上是–global）,全局安装之后，在任意的文件夹都可以访问到gulp</p>
<p>在在本地（当前目录上）安装（大多是包）不需要加-g </p>
<p>使用npm list 可以查看现在安装了的一些东西,npm list | grep 模块 可以查看其中某个模块的信息</p>
<p>使用npm info 模块  可以查看模块的信息及历史版本</p>
<p>使用npm install 模块@版本号 可以来安装对应的版本的模块包，原包就会被覆盖</p>
<p>因为npm在国内收到伟大的墙的限制，所以下载速度奇慢，所以可以使用cnpm（淘宝镜像）来下载</p>
<p>下载cnpm：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h2 id="注意，cnpm不是真正的npm，下载的资源来自与taobao服务器，下载到的东西和npm下载的是不一样-cnpm-不一定能使用list、info等等操作"><a href="#注意，cnpm不是真正的npm，下载的资源来自与taobao服务器，下载到的东西和npm下载的是不一样-cnpm-不一定能使用list、info等等操作" class="headerlink" title="注意，cnpm不是真正的npm，下载的资源来自与taobao服务器，下载到的东西和npm下载的是不一样;cnpm 不一定能使用list、info等等操作"></a>注意，cnpm不是真正的npm，下载的资源来自与taobao服务器，下载到的东西和npm下载的是不一样;cnpm 不一定能使用list、info等等操作</h2><h5 id="package-json相关："><a href="#package-json相关：" class="headerlink" title="package.json相关："></a>package.json相关：</h5><p>工程化：开始使用一些自动化工具来帮助我们构建项目。</p>
<p>我们可以通过npm init来创建package.json文件，这个文件可以来管理我们的<code>项目依赖的包的信息</code><br>``<br>devDependencies是开发依赖，也就是只在开发的时候使用的包 –save-dev （-D），depedencies是我们打包的时候依然使用的包–save （-S）</p>
<h2 id="这个文件还有一个好处，就是使我们的项目有辨识性，我们在某些情况下，需要将项目提交给某个地方或者共享给某人，这个时候我们不需要提交node——modules文件夹，只需要在那个地方执行npm-install-就可以安装package-json里所有的包，使我们的项目可以继续运行"><a href="#这个文件还有一个好处，就是使我们的项目有辨识性，我们在某些情况下，需要将项目提交给某个地方或者共享给某人，这个时候我们不需要提交node——modules文件夹，只需要在那个地方执行npm-install-就可以安装package-json里所有的包，使我们的项目可以继续运行" class="headerlink" title="这个文件还有一个好处，就是使我们的项目有辨识性，我们在某些情况下，需要将项目提交给某个地方或者共享给某人，这个时候我们不需要提交node——modules文件夹，只需要在那个地方执行npm install 就可以安装package.json里所有的包，使我们的项目可以继续运行"></a>这个文件还有一个好处，就是使我们的项目有辨识性，我们在某些情况下，需要将项目提交给某个地方或者共享给某人，这个时候我们不需要提交node——modules文件夹，只需要在那个地方执行npm install 就可以安装package.json里所有的包，使我们的项目可以继续运行</h2><h5 id="源相关："><a href="#源相关：" class="headerlink" title="源相关："></a>源相关：</h5><p>我们可以全局安装nrm这个工具来管理npm的源（就是下载地址），</p>
<p>nrm ls可以查看我们可以使用的源</p>
<p>nrm test可以来测试我们可以使用的源的速度</p>
<p>nrm use 源   可以来切换我们使用的源.</p>
<h5 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h5><h2 id="有的时候我们因为下载报错或者某种原因，需要重新下载的时候，结果依然报错，我们排除掉网络等原因后，可以尝试通过执行npm-cache-clear-来清除掉npm的缓存。"><a href="#有的时候我们因为下载报错或者某种原因，需要重新下载的时候，结果依然报错，我们排除掉网络等原因后，可以尝试通过执行npm-cache-clear-来清除掉npm的缓存。" class="headerlink" title="有的时候我们因为下载报错或者某种原因，需要重新下载的时候，结果依然报错，我们排除掉网络等原因后，可以尝试通过执行npm cache clear 来清除掉npm的缓存。"></a>有的时候我们因为下载报错或者某种原因，需要重新下载的时候，结果依然报错，我们排除掉网络等原因后，可以尝试通过执行npm cache clear 来清除掉npm的缓存。</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/node/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/node/" itemprop="url">node</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T21:23:16+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Node第二课"><a href="#Node第二课" class="headerlink" title="Node第二课"></a>Node第二课</h3><blockquote>
<p>一些常用的模块，如何使用node来像其他服务器发送请求….</p>
<h5 id="URL模块"><a href="#URL模块" class="headerlink" title="URL模块"></a>URL模块</h5><p>这个模块可以帮助我们解析url地址，从里面提取很多有用的内容供我们使用；<br>假设这是一个url地址<a href="http://localhost:8080/a/b/c?a=1&amp;b=2#abc，里面包含的部分：" target="_blank" rel="noopener">http://localhost:8080/a/b/c?a=1&amp;b=2#abc，里面包含的部分：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol: &apos;http:&apos;,</span><br><span class="line">host: &apos;localhost:8080&apos;,</span><br><span class="line">port: &apos;8080&apos;,</span><br><span class="line">hostname: &apos;localhost&apos;,</span><br><span class="line">hash: &apos;#abc&apos;,</span><br><span class="line">search: &apos;?a=1&amp;b=2&apos;,</span><br><span class="line">query: &apos;a=1&amp;b=2&apos;,</span><br><span class="line">pathname: &apos;/a/b/c&apos;,</span><br><span class="line">path: &apos;/a/b/c?a=1&amp;b=2&apos;,</span><br><span class="line">href: &apos;http://localhost:8080/a/b/c?a=1&amp;b=2#abc&apos;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])<br>会返回一个解析后的对象，第一个参数为要解析的url地址，第二个参数为是否将query字符串解析成对象格式，第二个参数来控制在没有协议的情况下，是否解析域名等内容<br>url.format(urlObject)<br>将一个url解析后的对象还原成一个url地址<br>url.resolve(from, to)<br>可以将我们两段url解析成一个url地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(url.resolve(&apos;http://www.baidu.com&apos;,&apos;/api/index.html&apos;;))</span><br><span class="line">//&apos;http://www.baidu.com/api/index.html&apos;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="queryString"><a href="#queryString" class="headerlink" title="queryString"></a>queryString</h3><p>可以将我们的queryString字符串(a=1&amp;b=2&amp;c=3)解析或反编译<br>querystring.stringify(obj[, sep[, eq[, options]]]):<br>可以将一个对象（键值对）解析成一个querystring,第二个参数可以设置分割符号（&amp;）,第三个参数确定键值对之间的链接符号（=）<br>querystring.parse(str[, sep[, eq[, options]]])<br>可以将一个qs字符串解析成一个对象，后面的参数是按照某种规则去解析<br>querystring.escape(str),querystring.unescape(str)<br>可以将我们的中文解析成百分号编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(qs.escape(&apos;北京&apos;))//%E5%8C%97%E4%BA%AC</span><br><span class="line">console.log(qs.unescape(&apos;%E5%8C%97%E4%BA%AC&apos;))//北京</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="http小爬虫"><a href="#http小爬虫" class="headerlink" title="http小爬虫"></a>http小爬虫</h4><h5 id="首先我们先研究一下什么是SEO"><a href="#首先我们先研究一下什么是SEO" class="headerlink" title="首先我们先研究一下什么是SEO"></a>首先我们先研究一下什么是SEO</h5><p>Search Engine Optimization 搜索引擎优化，是一种技术，目的是提高网页在搜索引擎的排行<br>如何能提高排行：</p>
<ol>
<li>给百度花钱</li>
<li>找专业的优化团队</li>
<li>开发过程中注意优化，例如，在不影响页面结构的情况下多使用语义化标签！img的title等也需要设置，title标签必须有，通过meta标签设置description、keywords、author；不需要使用ajax获取的数据就不要获取了，尽量可以使用服务端渲染数据的方式</li>
</ol>
<hr>
<p>利用http.get方法去获取到某网址的html文件内容，然后利用cheerio工具进行关键内容的提取</p>
<ol>
<li>获取到 <a href="https://www.lagou.com这个接口的数据（其实就是拉钩的首页文件）" target="_blank" rel="noopener">https://www.lagou.com这个接口的数据（其实就是拉钩的首页文件）</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">2.请求数据</span><br><span class="line">get方法可以模拟请求，获取到某个网址下的文件的内容，第一个参数url地址（要爬取的网址），回调函数里会返回一个res对象，可以给res对象绑定一些事件来进行操作</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>https.get(url,function(res){<br>    //存储我们爬取到的内容<br>    var html=’’;</p>
<pre><code>//data事件会在爬取到内容的时候触发多次，每一都会在回调函数里返回chunk（部分内容）
res.on(&apos;data&apos;,function(chunk){
    html+=chunk;
})
//end事件会在全部爬取完毕后触发
res.on(&apos;end&apos;,function(){
    //过滤出菜单内容
    var menuData=filterMenu(html);
    //输出菜单内容
    controlMenu(menuData)
})
//error事件在出现错误后触发，返回错误信息
res.on(&quot;error&quot;,function(err){
    console.log(err)
})
</code></pre><p>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.设计数据结构</span><br></pre></td></tr></table></figure></p>
<p>//设计的解析结构<br>//[<br>//    {<br>//        menuTitle:’技术’,<br>//        menuList:[<br>//            ‘java’,’php’<br>//        ]<br>//    }<br>//]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.解析html字符串并提取内容的函数</span><br></pre></td></tr></table></figure></p>
<p>function filterMenu(html){<br>    //将html字符串解析成模拟jq对象<br>    var $=cheerio.load(html);<br>    //存放菜单数据的数组<br>    var menuData=[];<br>    //获取到所有的菜单dom<br>    var menu=$(“.menu_main”);<br>    //遍历，过滤，提取<br>    menu.each(function(i,value){<br>        var menuTitle=$(value).find(‘h2’).text();<br>        var menuLists=$(value).find(‘a’);<br>        var menuList=[];<br>        menuLists.each(function(i,value){<br>            menuList.push($(value).text())<br>        })<br>        menuData.push({<br>            menuTitle:menuTitle,<br>            menuList:menuList<br>        })<br>    })</p>
<pre><code>return menuData;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.处理提取后内容的函数，这里只做了输出</span><br></pre></td></tr></table></figure></p>
<p>//处理过滤完成后菜单数据的函数<br>function controlMenu(menu){<br>    menu.forEach(function(item,index){<br>        console.log(item.menuTitle+’\n’);<br>        item.menuList.forEach(function(item,index){<br>            console.log(item+’\n’);</p>
<pre><code>    })
})
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关键技术点：https，https.get，data、end、error事件，cheerio模块</span><br><span class="line">---</span><br><span class="line">### requestGet/requestPost</span><br><span class="line">通过request来get数据（请求的是豆瓣电影的api）：</span><br><span class="line">1.引入模块和设置全局变量</span><br></pre></td></tr></table></figure></p>
<p>//引入https模块<br>const https = require(‘https’);<br>//配置请求的选项<br>//http的服务器的默认端口是80，https的服务器默认端口是443<br>var options = {<br>  hostname: ‘api.douban.com’,<br>  port: 443,<br>  path: ‘/v2/movie/in_theaters’,<br>  method: ‘GET’<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.设置请求的过程</span><br></pre></td></tr></table></figure></p>
<p>//发送请求并赋值变量<br>var req = https.request(options, (res) =&gt; {<br>  console.log(‘状态码：’, res.statusCode);<br>  console.log(‘请求头：’, res.headers);<br>  var requestData=’’;<br>  res.on(‘data’, (chunk) =&gt; {<br>      requestData+=chunk;<br>  });</p>
<p>  res.on(‘end’,function(){<br>      console.log(JSON.parse(requestData).subjects[0].title)<br>  })</p>
<p>});<br>//绑定错误处理事件<br>req.on(‘error’, (e) =&gt; {<br>  console.error(e);<br>});<br>//请求完成后end结束<br>req.end();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过request的post方法来刷评论（扣丁学堂）：</span><br><span class="line">1.引入模块和设置全局变量</span><br></pre></td></tr></table></figure></p>
<p>//引入http模块和qs模块<br>const http = require(‘http’);<br>const qs=require(‘querystring’);<br>//要发送的数据，需要解析成querystring（a=1&amp;b=2）<br>var postData=qs.stringify({<br>    ‘question[title]’:’1701表示很满意’,<br>    ‘question[content]’:’</p><p>1701表示很满意</p>‘,<br>    ‘question[courseId]’:’221’,<br>    ‘question[lessonId]’:’1698’,<br>    ‘_csrf_token’:’4df960e69a84f1a05b551cd66cff159f7bd70349’<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.配置请求的选项</span><br></pre></td></tr></table></figure><p></p>
<p>var options = {<br>  hostname: ‘www.codingke.com’;,<br>  port: 80,<br>  path: ‘/ajax/create/course/question’,<br>  method: ‘POST’,<br>    headers:{//这个例子需要传入headers，因为在cookie里保存了我们的登陆信息，没有登陆信息的话是不能评论的<br>        ‘Accept’:’<em>/</em>‘,<br>            ‘Accept-Encoding’:’gzip, deflate’,<br>            ‘Accept-Language’:’zh-CN,zh;q=0.8’,<br>            ‘Connection’:’keep-alive’,<br>            ‘Content-Length’:postData.length,<br>            ‘Content-Type’:’application/x-www-form-urlencoded; charset=UTF-8’,<br>            ‘Cookie’:’PHPSESSID=a7hmtvdr7odale2npuoe8kquo1; UM_distinctid=15bcc291625965-0b7625ecfa7e2b-4e47052e-100200-15bcc29162651c; CNZZDATA1256018185=1628677493-1493778687-null%7C1493778687; Hm_lvt_9f92046de4640f3c08cf26535ffdd93c=1493778896; Hm_lpvt_9f92046de4640f3c08cf26535ffdd93c=1493778931’,<br>            ‘Host’:’www.codingke.com’;,<br>            ‘Origin’:’<a href="http://www.codingke.com" target="_blank" rel="noopener">http://www.codingke.com</a>‘;,<br>            ‘Referer’:’<a href="http://www.codingke.com/v/326-chapter-221-course" target="_blank" rel="noopener">http://www.codingke.com/v/326-chapter-221-course</a>‘;,<br>            ‘User-Agent’:’Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36’,<br>            ‘X-CSRF-Token’:’4df960e69a84f1a05b551cd66cff159f7bd70349’,<br>            ‘X-Requested-With’:’XMLHttpRequest’<br>    }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.设置发送步骤</span><br></pre></td></tr></table></figure></p>
<p>//发送请求并赋值变量<br>var req = http.request(options, (res) =&gt; {<br>  res.on(‘data’, (chunk) =&gt; {<br>      console.log(chunk.toString())<br>  });</p>
<p>  res.on(‘end’,function(){<br>      console.log(‘发送成功’)<br>  })</p>
<p>});<br>//绑定错误处理事件<br>req.on(‘error’, (e) =&gt; {<br>  console.error(e);<br>});<br>//发送数据<br>req.write(postData)<br>//请求完成后end结束<br>req.end();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">### event_emitter</span><br><span class="line">nodejs是事件驱动的，比如前面res就有data、end事件，我们也可以创建一个对象，给它定义一些事件，在某种情况下去触发这个事件</span><br><span class="line">依靠的是events模块，请求到的啊eventEmitter类</span><br></pre></td></tr></table></figure></p>
<p>//引入EventEmitter模块，这是一个类class<br>const EventEmitter=require(‘events’)<br>//创建一个Player类来继承EventEmitter类<br>class Player extends EventEmitter {};<br>//实例化一个播放器对象<br>var player=new Player();<br>//给播放器对象添加一个事件<br>player.on(“play”,(name)=&gt;{<br>    console.log(‘正在播放:’+name)<br>})<br>//在某种情况下触发这个事件<br>player.emit(‘play’,’大头儿子小头爸爸’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">### fileStystem</span><br><span class="line">后端语言都有操作文件系统的能力，在nodejs里我们依靠的是fs模块</span><br><span class="line">每种操作的方法基本都有同异步的两种不同方法</span><br><span class="line">1.查看文件信息（多用来判断文件是否存在）exists</span><br></pre></td></tr></table></figure></p>
<p>var fs=require(‘fs’);<br>//异步查询文件信息<br>fs.stat(“../sources/temp.txt”,(err,data)=&gt;{<br>    if(err){<br>        console.log(err);<br>    }else{<br>        console.log(data)<br>        //判断是否是文件<br>        console.log(<code>文件:${data.isFile()}</code>)<br>        //判断是否是路径<br>        console.log(<code>目录:${data.isDirectory()}</code>)<br>    }<br>})<br>//同步查询<br>//fs.statSync(“../sources/temp.txt”)<br>console.log(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.创建一个目录</span><br></pre></td></tr></table></figure></p>
<p>//创建一个目录，如果目录已存在的话就会返回错误信息<br>fs.mkdir(“logs”,function(err){<br>    if(err){<br>        console.log(err);<br>    }else{<br>        console.log(‘success’);<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.写入文件</span><br></pre></td></tr></table></figure></p>
<p>//给文件写内容，当文件不存在会创建一个文件，第二个参数为写入的内容,每次写入都会覆盖<br>fs.writeFile(‘logs/hello.log’,’hello everyone\n’,function(err){<br>    if(err){<br>        console.log(err);<br>    }else{<br>        console.log(‘success’)<br>    }<br>})<br>//给文件中追加内容<br>fs.appendFile(“logs/hello.log”,’hello world\n’,function(err){<br>    if(err){<br>        console.log(err);<br>    }else{<br>        console.log(‘success’)<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.读取文件内容</span><br></pre></td></tr></table></figure></p>
<p>//读取文件内容的方法，第二个参数可选，为读取的编码格式<br>fs.readFile(“logs/hello.log”,’utf-8’,function(err,data){<br>    if(err){<br>        console.log(err);<br>    }else{<br>        console.log(data)<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.读取目录内容</span><br></pre></td></tr></table></figure></p>
<p>//读取目录内容，返回一个数组<br>fs.readdir(“logs”,function(err,files){<br>    if(err){<br>        console.log(err);<br>    }else{<br>        console.log(files)<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.文件重命名</span><br></pre></td></tr></table></figure></p>
<p>//重命名方法<br>fs.rename(“logs/hello.log”,”logs/world.log”,function(err){<br>    if(err){<br>        console.log(err)<br>    }else{<br>        console.log(‘success’)<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7.删除目录</span><br><span class="line">fs.rmdir可以删除目录但是，必须是空目录，fs.unlink可以删除文件，如果我们要删除一个目录及它下面的文件或子目录的话，我们需要先读取出来，删除完成后再进行根目录的删除</span><br></pre></td></tr></table></figure></p>
<p>fs.readdir(“logs”,function(err,data){<br>    if(err){<br>        console.log(err);<br>    }else{<br>        //[‘a’,’a.txt’]<br>        data.forEach(function(item,index){<br>            //判断这个东西是目录还是文件<br>            fs.stat(“logs/“+item,function(err,result){<br>                if(!err){<br>                    //根据判断结构来分别执行删除的方法<br>                    if(result.isFile()){<br>                        fs.unlinkSync(“logs/“+item)<br>                    }else{<br>                        fs.rmdirSync(“logs/“+item)</p>
<pre><code>                }

                if(index==data.length-1){                    
                    fs.rmdirSync(&quot;logs&quot;);
                }
            }else{
                console.log(err)
            }                
        })
    })        
}
</code></pre><p>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8.fs-extra模块</span><br><span class="line">这是一个第三方的fs模块，需要下载  npm install fs-extra</span><br><span class="line">fs模块上的方法它都有，并且还封装了一些很好用的方法，比如：copy、remove..</span><br><span class="line">[文档地址](https://www.npmjs.com/package/fs-extra)</span><br><span class="line">---</span><br><span class="line">### stream</span><br></pre></td></tr></table></figure></p>
<p>var fs=require(“fs”);<br>//创建一个文件读取流<br>var fileReadStream=fs.createReadStream(‘./sources/3theA.mp4’);<br>//创建一个文件写入流<br>var fileWriteStream=fs.createWriteStream(‘./sources/3theA_copy.mp4’);<br>//给读取流绑定data事件，当我们一点一点读取到内容的时候就会触发，这个时候再把读取到的一点内容通过写入流马上写入<br>//优点不会占用多的缓冲区 的内存，适合于操作大文件<br>fileReadStream.on(“data”,function(chunk){<br>    fileWriteStream.write(chunk)<br>})<br>fileReadStream.on(“end”,function(){<br>    console.log(‘end’);<br>})<br>fileReadStream.on(“error”,function(err){<br>    console.log(err)<br>})<br>```</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="董小姐儿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T10:49:55+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">董小姐儿</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董小姐儿</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
